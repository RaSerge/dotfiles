" Modeline and Notes {{{
" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={{{,}}} foldlevel=0 foldmethod=marker spell:
" }}}

" Vim-plug {{{
    " Auto-install Vim-plug (if needed)
    if empty(glob('~/.vim/autoload/plug.vim'))
        silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
                    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        autocmd VimEnter * PlugInstall
    endif
    call plug#begin('~/.vim/plugged')

    " The list of installed plugins
    Plug 'Konfekt/FastFold'             " Better fold refresh
    Plug 'SirVer/ultisnips'             " Snippets engine
    Plug 'honza/vim-snippets'           " Vim snippets
    Plug 'bogado/file-line'             " Open vim file:line
    Plug 'christoomey/vim-sort-motion'  " Add sort motion
    Plug 'cohama/lexima.vim'            " Wonderful auto-pair
    Plug 'ctrlpvim/ctrlp.vim'           " Fuzzy file, buffer, MRU, tag finder
    Plug 'junegunn/vim-easy-align'      " Auto-align text
    Plug 'junegunn/vim-peekaboo'        " See content of registers
    Plug 'majutsushi/tagbar'            " Show a cool tagbar (requires ctags)
    Plug 'scrooloose/syntastic'         " Syntax Checkers
    Plug 'terryma/vim-multiple-cursors' " Multiple cursors in vim
    Plug 'tpope/vim-commentary'         " Toggle comments
    Plug 'tpope/vim-repeat'             " Enable supported plugin actions to be repeated with '.'
    Plug 'tpope/vim-surround'           " All about surrounding
    Plug 'tpope/vim-vinegar'            " Lightweight file manager
    Plug 'vim-airline/vim-airline'      " Better statusbar

    " Completion handling
    Plug 'Valloric/YouCompleteMe',
                \ { 'do': './install.py --clang-completer --gocode-completer'}

    " Appearance
    Plug 'luochen1990/rainbow'          " Rainbow parenthesis (no more messes!)
    Plug 'fatih/molokai'                " Molokai color scheme
    Plug 'fmoralesc/molokayo'           " Molokai improved

    " Language specific plugins {{{
        " Python
        Plug 'klen/python-mode', { 'for': 'python' } " VIM as a powerful Python IDE

        " Markdown
        Plug 'jtratner/vim-flavored-markdown'        " GitHub flavored markdown
        Plug 'suan/vim-instant-markdown',
                    \ { 'for' : 'markdown' }         " Instant markdown preview in browser (requirements on GitHub)

        " Latex
        Plug 'lervag/vimtex', {'for': 'tex' }

        " Go
        Plug 'fatih/vim-go', { 'for': 'go' }         " Go suite
    " }}}

    " Enable Vim-stay after all the other plugins
    Plug 'kopischke/vim-stay'                 " Save and restore cursor position, folds and so on

    " ...Vim-plug is done
    call plug#end()
" }}}

" General {{{
    set nocompatible                        " Disable useless backward compatibility

    " Sets how many lines of history VIM has to remember
    set history=1000

    " Set to auto read when a file is changed from the outside
    set autoread

    " Modeline in the first five lines
    set modeline
    set modelines=5

    " Mouse
    set mouse=a
    set mousehide               " Hide the mouse cursor while typing

    " End of line (unix EOL is preferred over the dos one and before the mac one).
    set fileformats=unix,dos,mac

    " With a map leader it's possible to do extra key combinations
    let g:mapleader = "\<Space>"
    let g:maplocalleader = "\<Space>"
" }}}

" Backup, swap, info and ignore files {{{
    set noswapfile  " Stop annoying swap files

    " Save your backups to a less annoying place than the current directory.
    " If you have .vim-backup in the current directory, it'll use that.
    " Otherwise it saves it to ~/.vim/backup or . if all else fails.
    if isdirectory($HOME . '/.vim/backup') == 0
        :silent !mkdir -p ~/.vim/backup >/dev/null 2>&1
    endif
    set backupdir-=.
    set backupdir+=.
    set backupdir-=~/
    set backupdir^=~/.vim/backup/
    set backupdir^=./.vim-backup/
    set backup

    " Save your swap files to a less annoying place than the current directory.
    " If you have .vim-swap in the current directory, it'll use that.
    " Otherwise it saves it to ~/.vim/swap, ~/tmp or .
    if isdirectory($HOME . '/.vim/swap') == 0
        :silent !mkdir -p ~/.vim/swap >/dev/null 2>&1
    endif
    set directory=./.vim-swap//
    set directory+=~/.vim/swap//
    set directory+=~/tmp//
    set directory+=.

    " Tell (n)vim to remember certain things when we exit
    "  '20  :  marks will be remembered for up to 10 previously edited files
    "  "100 :  will save up to 100 lines for each register
    "  :1000  :  up to 1000 lines of command-line history will be remembered
    "  %    :  saves and restores the buffer list
    "  n... :  where to save the viminfo files
    if has('nvim')
    set shada='20,<100,:1000,%,n~/.nvim/nviminfo
    set viewdir=~/.vim/view
    else
    set viminfo='20,\"100,:100,%,n~/.vim/viminfo
    endif

    if exists("+undofile")
        " undofile - This allows you to use undos after exiting and restarting
        " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
        " :help undo-persistence
        " This is only present in 7.3+
        if isdirectory($HOME . '/.vim/undo') == 0
            :silent !mkdir -p ~/.vim/undo > /dev/null 2>&1
        endif
        set undodir=./.vim-undo//
        set undodir+=~/.vim/undo//
        set undofile
    endif

    " Ignore unreadable files, images, etc.
    set wildignore=*.o,*~,*.pyc
    set wildignore+=*.png,*.gif,*.jpg,*.ico
    set wildignore+=.git,.svn,.hg
    set wildignore+=*/tmp/*,*.so,*.swp,*.zip

    " Save cursor position, folds, and so on.
    set viewoptions=cursor,folds,slash,unix
" }}}

" Appearance {{{
    syntax on

    "Always show current position
    set cursorline                   " highlights the current line

    " Height of the command bar
    set cmdheight=1

    set background=dark
    colorscheme molokai

    set scrolloff=8       " don't scroll any closer to top/bottom
    set sidescrolloff=5   " don't scroll any closer to left/right

    " No annoying sound on errors
    set noerrorbells visualbell t_vb=
    if has('autocmd')
        augroup no_visual_bell
            autocmd!
            autocmd GUIEnter * set visualbell t_vb=
        augroup END
    endif

    " Line and relative numbers
    set number
    set relativenumber

    set showmatch                   " Show matching brackets/parenthesis
    set matchtime=2                 " How many tenths of seconds to blink matching bracket/parenthesis

    set linespace=0                 " No extra spaces between rows in GUI

    " How to show completion informations in insert mode
    set completeopt=menu,longest

    " Allow the cursor to be one more the last char.
    set virtualedit=onemore

    " Disable split separators
    set fillchars=""
" }}}

" Search and commands {{{
    set showcmd               " Display incomplete commands

    " Magic pattern matching
    set magic

    set incsearch             " Find as you type search
    set hlsearch              " Highlight search terms
    set ignorecase            " Case insensitive search
    set smartcase             " Case sensitive when upper case is present
    set gdefault

    set wildmenu              " Show list instead of just completing
    set wildmode=longest,full " Command <Tab> completion, list matches, then longest common part, then all.

    " Use sane magic regexes
    nnoremap / /\v
    vnoremap / /\v
" }}}

" Text, lines, tab, indent and folding {{{
    " Set utf-8 as standard encoding
    set encoding=utf-8                             " The encoding displayed.
    set fileencoding=utf-8                         " The encoding written to file.

    set backspace=indent,eol,start                 " Backspace for dummies
    set whichwrap=b,s,h,l,<,>,[,]                  " Backspace and cursor keys wrap too
    set list                                       " Display whites
    set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespace

    set expandtab                                  " In insert mode, insert the appropriate number of spaces to insert a Tab
    set smarttab                                   " Insert tabs in front of lines according to shiftwidth
    set shiftwidth=4                               " operation >> indents 4 columns; << unindents 4 columns
    set tabstop=4                                  " a hard TAB displays as 4 columns
    set expandtab                                  " insert spaces when hitting TABs
    set softtabstop=4                              " insert/delete 4 spaces when hitting a TAB/BACKSPACE
    set shiftround                                 " round indent to multiple of 'shiftwidth'
    set autoindent                                 " align the new line indent with the previous line
    set cindent                                    " automatic C programming indenting

    " Visually wrap lines too long
    set wrap
    " Turn off physical line wrapping
    set textwidth=0 wrapmargin=0

    " Do not insert comment leader on 'o'
    set formatoptions-=o

    if has("autocmd")
        augroup GIT_COMMIT
            autocmd!
            autocmd Filetype gitcommit setlocal spell textwidth=72
        augroup end
    endif

    if has("autocmd")
        augroup LATEX
            autocmd!
            autocmd Filetype tex setlocal spell conceallevel=0 synmaxcol=200 foldmethod=manual ttyfast lazyredraw
        augroup end
    endif

    if has("autocmd")
        augroup MDOWN
            autocmd!
            autocmd Filetype ghmarkdown,markdown,md setlocal spell
        augroup end
    endif
" }}}

" Tabs, windows and buffers {{{
    set hidden  " Allows to change buffer without saving

    " Open new split panes to right and bottom, which feels more natural
    set splitbelow
    set splitright

    " Switch CWD to the directory of the open buffer
    set autochdir

    " Auto save on :next, :edit, :quit, etc.
    set autowriteall

    " Smart way to move between windows
    nnoremap <C-h> <C-w>h
    nnoremap <C-j> <C-w>j
    nnoremap <C-k> <C-w>k
    nnoremap <C-l> <C-w>l

    " Same smart ways with nvim terminal buffers
    if has('nvim')
        tnoremap <C-h> <C-\><C-n><C-w>h
        tnoremap <C-j> <C-\><C-n><C-w>j
        tnoremap <C-k> <C-\><C-n><C-w>k
        tnoremap <C-l> <C-\><C-n><C-w>l
    endif

    " Close the current buffer
    nnoremap <leader>bd :bd<cr>

    " Close all the buffers
    nnoremap <leader>ba :bufdo bdelete<cr>

    " Move to next buffer
    nnoremap <leader>bn :bnext<cr>
    nnoremap <leader>bp :bprevious<cr>

    " Useful mappings for managing tabs
    nnoremap <leader>tn :tabnew<cr>
    nnoremap <leader>to :tabonly<cr>
    nnoremap <leader>tc :tabclose<cr>
    nnoremap <leader>tm :tabmove

    " Opens a new tab with the current buffer's path
    " Super useful when editing files in the same directory
    nnoremap <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/

    " Specify the behavior when switching between buffers
    try
        set switchbuf=useopen,usetab,newtab
        set showtabline=2
    catch
    endtry

    " Code folding mappings
    nmap <leader>f0 :set foldlevel=0<CR>
    nmap <leader>f1 :set foldlevel=1<CR>
    nmap <leader>f2 :set foldlevel=2<CR>
    nmap <leader>f3 :set foldlevel=3<CR>
    nmap <leader>f4 :set foldlevel=4<CR>
    nmap <leader>f5 :set foldlevel=5<CR>
    nmap <leader>f6 :set foldlevel=6<CR>
    nmap <leader>f7 :set foldlevel=7<CR>
    nmap <leader>f8 :set foldlevel=8<CR>
    nmap <leader>f9 :set foldlevel=9<CR>

    " Exclude quickfix windows from buflist
    if has("autocmd")
        augroup qf
            autocmd!
            autocmd FileType qf set nobuflisted
        augroup END
    endif

    if has("autocmd")
        augroup buffers_windows_more
            autocmd!

            " Save when losing focus
            au FocusLost * :silent! wall

            " Resize splits when the window is resized
            au VimResized * :wincmd =
        augroup END
    endif
" }}}

" Misc mappings {{{
    " Remap VIM 0 to first non-blank character
    map 0 ^

    " Treat long lines as break lines (useful when moving around in them)
    noremap j gj
    noremap k gk
    noremap gj j
    noremap gk k

    " Disable highlight when <leader><cr> is pressed
    nnoremap <silent> <leader><cr> :noh<cr>

    " Toggle paste mode on and off
    nnoremap <leader>pp :setlocal paste!<cr>

    " Make Y yank everything from the cursor to the end of the line.
    noremap Y y$

    if &term =~ '^screen'
        " tmux will send xterm-style keys when xterm-keys is on
        execute "set <xUp>=\e[1;*A"
        execute "set <xDown>=\e[1;*B"
        execute "set <xRight>=\e[1;*C"
        execute "set <xLeft>=\e[1;*D"
    endif
" }}}

" Spell checking {{{
    " Pressing ,ss will toggle and untoggle spell checking
    map <leader>ss :setlocal spell!<cr>

    " Shortcuts using <leader>
    nnoremap <leader>sn ]s
    nnoremap <leader>sp [s
    nnoremap <leader>sa zg
    nnoremap <leader>s? z=
" }}}

" Misc {{{
    set iskeyword-=.                    " '.' is an end of word designator
    set iskeyword-=#                    " '#' is an end of word designator
    set iskeyword-=-                    " '-' is an end of word designator

    if has("autocmd")
        " Highlight TODO, FIXME, NOTE, etc.
        augroup annotations
            autocmd!
            autocmd Syntax * call matchadd('Todo',  '\W\zs\(TODO\|FIXME\|CHANGED\|XXX\|BUG\|HACK\)')
            autocmd Syntax * call matchadd('Debug', '\W\zs\(NOTE\|INFO\|IDEA\|DEBUG\)')
        augroup END
    endif

    if executable("ag")
        set grepprg=ag\ --vimgrep\ $*
        set grepformat=%f:%l:%c:%m
    elseif executable("ack")
        set grepprg=ack\ -k
    endif
" }}}

" Helper functions {{{
    " Convenient command to see the difference between the current buffer and the
    " file it was loaded from, thus the changes you made.
    " Only define it when not defined already.
    if !exists(':DiffOrig')
        command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
                    \ | wincmd p | diffthis
    endif

    " Strip whitespace {{{
    function! StripTrailingWhitespace()
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " do the business:
        %s/\s\+$//e
        " clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction
    " }}}

    " Before saving, delete trailing white-spaces and ^M
    augroup delete_trailing
        autocmd!
        autocmd FileType c,cpp,java,php,javascript,python,twig,xml,yml,vim,tex,lua autocmd BufWritePre <buffer> call StripTrailingWhitespace()
    augroup END
" }}}

" Plugin settings {{{
    " Tagbar {{{
        nnoremap <silent> <leader>tb :TagbarToggle<CR>
    " }}}

    " CtrlP {{{
        let g:ctrlp_map = '<c-p>'
        let g:ctrlp_cmd = 'CtrlP'

        " Use the nearest .git directory as the cwd
        " This makes a lot of sense if you are working on a project that is
        " in version control. It also supports works with .svn, .hg, .bzr.
        let g:ctrlp_working_path_mode = 'ra'

        let g:ctrlp_cache_dir = $HOME.'/.vim/.cache/ctrlp'
        let g:ctrlp_match_window_reversed = 1
        let g:ctrlp_clear_cache_on_exit = 0

        " Automatically enable CtrlP extensions.
        let g:ctrlp_extensions = ['buffertag', 'quickfix', 'undo', 'line', 'changes', 'mixed']

    " }}}

    " Vim Airline / Statusbar {{{
        let g:bufferline_echo = 0
        set noshowmode   " do not show default mode indicator
        set laststatus=2 " always show the statusbar

        " general configuration
        let g:airline#extensions#disable_rtp_load = 1 " do not find extensions in run time path
        let g:airline_powerline_fonts             = 1 " powerline fonts

        " custom symbols
        if !exists('g:airline_symbols')
            let g:airline_symbols = {}
        endif

        let g:airline_symbols.linenr    = ''
        let g:airline_symbols.maxlinenr = ''
        let g:airline_symbols.spell     = 'S'
        let g:airline_symbols.paste     = 'P'

        " extensions
        " only load what you want
        let g:airline_extensions = [ 'syntastic', 'tagbar', 'ctrlp', 'virtualenv', 'tabline' ]

        let g:airline#extensions#tabline#fnamemod   = ':t' " only show filename in tab
        let g:airline#extensions#quickfix#quickfix_text = 'Quickfix'
        let g:airline#extensions#quickfix#location_text = 'Location'

    " }}}

    " Syntastic {{{
        let g:syntastic_check_on_open            = 1 " Automatically check on file open
        let g:syntastic_always_populate_loc_list = 1 " Fill location list
        let g:syntastic_auto_loc_list            = 2 " Close it when no errors are detected

        let g:syntastic_error_symbol         = "\u2718"
        highlight SyntasticErrorSign ctermbg=235 ctermfg=red guifg=red

        let g:syntastic_warning_symbol       = "\u2718"
        highlight SyntasticWarningSign ctermbg=235 ctermfg=208 guifg=orange

        let g:syntastic_style_error_symbol   = "\u26A0"
        highlight link SyntasticStyleErrorSign SyntasticErrorSign

        let g:syntastic_style_warning_symbol   = "\u26A0"
        highlight link SyntasticStyleWarningSign SyntasticWarningSign

        " Aggregate checkers
        let g:syntastic_aggregate_errors = 1

        " Syntastic status line for airline
        let g:syntastic_stl_format = "%E{#%e Errs: %fe}%B{, }%W{#%w Warns: %fw}"

        " Language specific checkers {{{
            " Java
            let g:syntastic_java_checkers = []

            " Go
            let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']

            " Enable again perl checker
            let g:syntastic_enable_perl_checker = 1
            let g:syntastic_perl_checkers = ['perl']

            " Enable check C headers file
            let g:syntastic_c_check_header = 1
            let g:syntastic_c_compiler_options = '-Wall'

            " Enable C++11 standard
            let g:syntastic_cpp_compiler_options="-std=c++11 -stdlib=libc++ -Wall"

            " Javascript
            let g:syntastic_javascript_jshint_args = "--extract=auto"

            " Lua
            let g:syntastic_lua_checkers = ['luac', 'luacheck']
        " }}}
    " }}}

    " Rainbow parenthesis {{{
        let g:rainbow_active = 1  " Activate rainbows
    " }}}

    " Auto-pairs-gentle {{{
        let g:AutoPairsUseInsertedCount = 1  " Make it gentle

        if has('autocmd')
            augroup no_lisp_autopair
                autocmd!
                autocmd Filetype lisp let b:AutoPairs = {}
            augroup END
        endif
    " }}}

    " Multi Cursors {{{
        let g:multi_cursor_exit_from_visual_mode = 1  " Keep cursors when exiting from V mode
    " }}}

    " YouCompleteMe / Ultisnips {{{
        let g:ycm_autoclose_preview_window_after_completion = 1

        " enable completion from tags
        let g:ycm_collect_identifiers_from_tags_files       = 1
        let g:ycm_use_ultisnips_completer                   = 1 " Default 1, just ensure
        let g:ycm_seed_identifiers_with_syntax              = 1 " Completion for programming language's keyword
        let g:ycm_complete_in_comments                      = 1 " Completion in comments
        let g:ycm_complete_in_strings                       = 1 " Completion in string
        let g:ycm_add_preview_to_completeopt                = 0 " Add preview to completeopt

        " Disable YCM syntax checker in favour of syntastic
        let g:ycm_show_diagnostics_ui                       = 0  " Use syntastic checker
        " Disable YCM detailed diagnostic
        let g:ycm_key_detailed_diagnostics = ''

        " remap Ultisnips for compatibility for YCM
        let g:UltiSnipsExpandTrigger                        = '<C-j>'
        let g:UltiSnipsJumpForwardTrigger                   = '<C-j>'
        let g:UltiSnipsJumpBackwardTrigger                  = '<C-b>'
        let g:UltiSnipsListSnippets                         = "<C-k>"

        nnoremap <leader>g :YcmCompleter GoToDefinitionElseDeclaration<CR>

        " For snippet_complete marker.
        if has('conceal')
            set conceallevel=2 concealcursor=i
        endif

        " Snippets variables
        let g:author='Adriano Di Luzio'
        let g:snips_author=g:author
        let g:email='adrianodl@hotmail.it'
        let g:snips_email=g:email
        let g:github='https://github.com/aldur'
        let g:snips_github=g:github
    " }}}

    " GitHub Flavored Markdown "{{{
        augroup markdown
            au!
            au BufNewFile,BufRead *.md,*.markdown setlocal filetype=ghmarkdown
        augroup END
    " }}}

    " Vim Instant Markdown {{{
        let g:instant_markdown_slow = 1
    " }}}

    " Py-Mode {{{
        let g:pymode = 1
        let g:pymode_warnings = 0

        let g:pymode_trim_whitespaces = 1  " We already do that
        let g:pymode_options = 0
        let g:pymode_options_colorcolumn = 0
        let g:pymode_indent = 1
        let g:pymode_folding = 0
        let g:pymode_motion = 1

        let g:pymode_doc = 1
        let g:pymode_doc_bind = 'K'

        let g:pymode_breakpoint = 0
        let g:pymode_virtualenv = 1

        " Enable manual linting only
        let g:pymode_lint = 1
        let g:pymode_lint_on_write = 0
        let g:pymode_lint_unmodified = 0
        let g:pymode_lint_on_fly = 0
        let g:pymode_lint_message = 0

        let g:pymode_syntax = 1
        let g:pymode_syntax_all = 1
        let g:pymode_syntax_print_as_function = 1
        let g:pymode_syntax_slow_sync = 1

        let g:pymode_rope = 0
        let g:pymode_rope_completion = 0
        let g:pymode_rope_complete_on_dot = 0
        let g:pymode_rope_lookup_project = 0
        let g:pymode_rope_autoimport = 0

        " Automatically fix PEP8 errors in the current buffer:
        if has('autocmd')
            augroup autopep8
                autocmd!
                autocmd Filetype python noremap <F8> :PymodeLintAuto<CR>
            augroup END
        endif
    "}}}

    " Vimtex settings {{{
        let g:vimtex_enabled = 1
        let g:tex_flavor = "latex"  " Open '.tex' files as 'tex' and not 'plaintex'.

        let g:vimtex_quickfix_mode = 2  " Auto-open with no focus.
        let g:vimtex_latexmk_build_dir = "build"

        " Skim as a PDF viewer
        let g:vimtex_view_general_viewer = '/Applications/Skim.app/Contents/SharedSupport/displayline'
        let g:vimtex_view_general_options = '-r @line @pdf @tex'

        " This adds a callback hook that updates Skim after compilation
        let g:vimtex_latexmk_callback_hooks = ['UpdateSkim']
        function! UpdateSkim(status)
            if !a:status | return | endif

            let l:out = b:vimtex.out()
            let l:cmd = [g:vimtex_view_general_viewer, '-r']
            if !empty(system('pgrep Skim'))
                call extend(l:cmd, ['-g'])
            endif
            if has('nvim')
                call jobstart(l:cmd + [line('.'), l:out])
            elseif has('job')
                call job_start(l:cmd + [line('.'), l:out])
            else
                call system(join(l:cmd + [line('.'), shellescape(l:out)], ' '))
            endif
        endfunction

        " YCM semantic completion
        if !exists('g:ycm_semantic_triggers')
            let g:ycm_semantic_triggers = {}
        endif
        let g:ycm_semantic_triggers.tex = [
                    \ 're!\\[A-Za-z]*cite[A-Za-z]*(\[[^]]*\]){0,2}{[^}]*',
                    \ 're!\\[A-Za-z]*ref({[^}]*|range{([^,{}]*(}{)?))',
                    \ 're!\\hyperref\[[^]]*',
                    \ 're!\\includegraphics\*?(\[[^]]*\]){0,2}{[^}]*',
                    \ 're!\\(include(only)?|input){[^}]*',
                    \ 're!\\\a*(gls|Gls|GLS)(pl)?\a*(\s*\[[^]]*\]){0,2}\s*\{[^}]*',
                    \ 're!\\includepdf(\s*\[[^]]*\])?\s*\{[^}]*',
                    \ 're!\\includestandalone(\s*\[[^]]*\])?\s*\{[^}]*',
                    \ ]

        " Disable insert mode mappings
        let g:vimtex_imaps_enabled = 0

        augroup latexSurround
            autocmd!
            autocmd FileType tex call s:latexSurround()
        augroup END

        function! s:latexSurround()
            let b:surround_{char2nr("e")}
                        \ = "\\begin{\1environment: \1}\n\t\r\n\\end{\1\1}"
            let b:surround_{char2nr("c")} = "\\\1command: \1{\r}"
        endfunction
    " }}}

    " Vim-easy-align {{{
        " Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
        vmap <Enter> <Plug>(EasyAlign)

        " Start interactive EasyAlign for a motion/text object (e.g. gaip)
        nmap ga <Plug>(EasyAlign)
    " }}}

    " Molokai {{{
        let g:molokai_original = 1
    " }}}

    " Vim-Go {{{
        " Enable better syntax highlighting
        let g:go_highlight_functions = 1
        let g:go_highlight_methods = 1
        let g:go_highlight_fields = 1
        let g:go_highlight_structs = 1
        let g:go_highlight_interfaces = 1
        let g:go_highlight_operators = 1
        let g:go_highlight_build_constraints = 1

        " On recent VIM version better go fmt should work
        let g:go_fmt_experimental = 1

        " Show info for word under cursor
        let g:go_auto_type_info = 1

        if has('autocmd')
            augroup vim_go_mappings
                autocmd!
                au FileType go nmap <leader>r <Plug>(go-run)
                au FileType go nmap <leader>b <Plug>(go-build)
                au FileType go nmap <leader>t <Plug>(go-test)
                au FileType go nmap <leader>c <Plug>(go-coverage)

                au FileType go nmap <Leader>ds <Plug>(go-def-split)
                au FileType go nmap <Leader>dv <Plug>(go-def-vertical)
                au FileType go nmap <Leader>dt <Plug>(go-def-tab)

                au FileType go nmap <Leader>gd <Plug>(go-doc)
                au FileType go nmap <Leader>gv <Plug>(go-doc-vertical)

                au FileType go nmap <Leader>e <Plug>(go-rename)
                au FileType go nmap <Leader>i <Plug>(go-imports)
                au FileType go nmap <Leader>s <Plug>(go-implements)
            augroup END
        endif

        " Syntastic integration
        let g:go_list_type = "quickfix"
    " }}}
" }}}

" Ending settings {{{
    if filereadable(expand("~/.vimrc.local"))
        source ~/.vimrc.local
    endif

    set secure
" }}}
